using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

public class Molblin1 : MonoBehaviour
{
    #region 변수
    static public Molblin1 instance = null;
    private void Awake()
    {
        instance = this;
    }

    // 상태
    public MolblinnState state;

    // 상태 열거
    public enum MolblinnState
    {
        Idle, 
        Move, 
        Dodge, 
        Wait, 
        Attack, 
        AttackWait, 
        Damaged,
        Die
    }

    // 이동속도
    public float speed = 3;

    // 거리
    float distance;
    public float detectDistance;
    public float attackPossibleDistance;
    public float attackDistance;
    public Transform dodgePos;

    // 시간
    float currentTime;
    public float waitTime;

    // 플레이어(링크)
    GameObject link;
    Vector3 linkDir;

    // 애니메이션
    Animator anim;

    // 체력
    public int currentHP;
    public int maxHP = 30;

    Rigidbody rb;

    // bool
    bool isWait;
    bool isAttack;
    bool isDisturb = true;
    #endregion

    #region Start
    // Start is called before the first frame update
    void Start()
    {
        currentHP = maxHP;
        link = GameObject.Find("Player");
        rb = GetComponent<Rigidbody>();
        anim = gameObject.GetComponentInChildren<Animator>();
    }
    #endregion

    #region Upadate
    // Update is called once per frame
    void Update()
    {
        #region 바라보기
        // 링크가 있는 방향을 찾는다.
        linkDir = link.transform.position - transform.position;
        linkDir.y = 0;
        linkDir.Normalize();
        Quaternion linkRotate = Quaternion.LookRotation(linkDir);

        // 그 방향을 바라본다.
        transform.rotation = Quaternion.Lerp(transform.rotation, linkRotate, Time.deltaTime * 5);
        #endregion

        #region 거리재기
        // 거리를 구한다.
        Vector3 y = link.transform.position;
        y.y = transform.position.y;
        distance = Vector3.Distance(y, transform.position);
        #endregion

        #region 회피하기
        // 만약 링크가 3M 보다 더 가까이 다가온다면
        if(distance < 3)
        {
            if (isWait || isAttack)
            {
                // 아무일도 일어나지 않는다.
                return;
            }

            // 30% 확률로 회피한다.
            int dodgeValue = Random.Range(0, 10);
            if (dodgeValue < 3 && isWait == false)
            {
                isWait = true;
                state = MolblinnState.Dodge;
                currentTime = 0;
                // 애니메이션 실행
                anim.SetTrigger("Dodge");
            }
            // 나머지 확률로
            else
            {
                state = MolblinnState.Attack;
                isWait = false;
            }
        }
        #endregion

        if (state == MolblinnState.Idle)
        {
            UpdateIdle();
        }
        else if (state == MolblinnState.Move)
        {
            UpdateMove();
        }
        else if (state == MolblinnState.Dodge)
        {
            UpdateDodge();
        }
        else if (state == MolblinnState.Wait)
        {
            UpdateWait();
        }
        else if (state == MolblinnState.Attack)
        {
            UpdateAttack();
        }
        else if (state == MolblinnState.AttackWait)
        {
            UpdateAttackWait();
        }
        else if (state == MolblinnState.Damaged)
        {
            UpdateDamaged();
        }
        else if (state == MolblinnState.Die)
        {
            UpdateDie();
        }
    }
    #endregion

    #region Updates
    private void UpdateDodge()
    {
        state = MolblinnState.Idle;
        isWait = false;
    }

    bool isPohyo = false;
    private void UpdateIdle()
    {
        // 만약 링크와의 거리가 감지 거리보다 가까우면
        if (distance <= detectDistance)
        {
            currentTime += Time.deltaTime;
            if (isPohyo == false)
            {
                // 포효를 하고 
                isPohyo = true;
                anim.SetTrigger("Buff");
            }

            // 3초가 지나면
            if (currentTime > 3 && isPohyo)
            {
                // 상태를 Move 로 변환한다.
                state = MolblinnState.Move;
                anim.SetBool("Move", true);
                currentTime = 0;
            }
        }
    }

    private void UpdateMove()
    {
        // 만약 링크와의 거리가 감지 거리보다 멀어지면 Idle 상태로 돌아간다.
        if (distance > detectDistance)
        {
            // 상태를 Idle 로 전환한다.
            state = MolblinnState.Idle;
            anim.SetBool("Move", false);
        }

        // 만약 링크와의 거리가 감지거리보다 가깝고 공격가능거리보다 멀면 이동한다.
        else if (detectDistance > distance && distance > attackPossibleDistance)
        {
            // 링크가 있는 곳으로 이동한다.
            transform.position += linkDir * speed * Time.deltaTime;
        }

        // 링크가 공격 거리 안으로 들어오면 기다린다.
        else if (distance <= attackPossibleDistance)
        {
            // 공격대기상태로 전환한다.
            state = MolblinnState.Wait;

            // 애니메이션
            anim.SetBool("Move", false);
        }
    }

    private void UpdateWait()
    {
        // 시간을 흐르게 한다.
        currentTime += Time.deltaTime;

        // 대기 시간 중에 링크가 공격거리 보다 멀어진다면 Idle
        if (distance > attackPossibleDistance)
        {
            // 상태를 Idle 로 전환한다.
            state = MolblinnState.Idle;
            
            isWait = false;
        }
        // 대기 시간이 지나면 Dodge or Attack
        if (currentTime >= waitTime)
        {
            // 링크가 있는 곳까지 이동한다.
            transform.position += linkDir * speed * Time.deltaTime;
            anim.SetBool("Move", true);

            if (distance <= attackDistance)
            {
                anim.SetBool("Move", false);

                // 공격 패턴 중 하나를 골라 실행한다.
                state = MolblinnState.Attack;

                // 시간을 초기화한다.
                currentTime = 0;
            }
        }   
    }

    private void UpdateAttack()
    {
        isAttack = true;
        // 링크가 모리블린의 공격을 피하려고 엄청 가까이 다가오면
        if (distance <= 3)  
        {
            // 공격패턴 1 실행
            anim.SetTrigger("Kick");
            Kick();
        }
        // 그게 아니라면
        else
        {
            int attackValue = Random.Range(0, 5);
            // 60% 확률로 공격패턴 2 실행
            if (attackValue < 3)
            {
                anim.SetTrigger("TwoHands");
                TwoHandsAttack();
            }

            // 40% 확률로 공격패턴 3 실행
            else
            {
                anim.SetTrigger("ComboAttack");
                ComboAttack();
            }
        }
    }

    private void Kick()
    {
        print("1");

        currentTime += Time.deltaTime;
        if(currentTime >= 2)
        {
            isAttack = false;
            state = MolblinnState.Idle;
            currentTime = 0;
        }        
    }

    private void TwoHandsAttack()
    {
        print("2");
        
        currentTime += Time.deltaTime;
        if (currentTime >= 3)
        {
            isAttack = false;
            isDisturb = false;
            state = MolblinnState.Idle;
            currentTime = 0;
        }
    }

    private void ComboAttack()
    {        
        print("3");
        
        currentTime += Time.deltaTime;
        if (currentTime >= 5)
        {
            isAttack = false;
            isDisturb = false;
            state = MolblinnState.Idle;
            currentTime = 0;
        }
    }

    private void UpdateAttackWait()
    {
        isAttack = false;
        isDisturb = true;
        state = MolblinnState.Idle;

        //// 다음 공격시간까지 대기하는 도중에 링크가 공격거리에서 멀어지면 Idle
        //if (currentTime < 3 && distance > attackDistance)
        //{
        //    // 현재시간을 초기화한다.
        //    currentTime = 0;
            
        //    // 상태를 Idle 로 바꾼다.
        //    state = MolblinnState.Idle;

        //    //anim.SetBool("AttackWait", false);
        //}

        //// 2초가 지나면 다시 공격
        //else if (currentTime >= 2)
        //{
        //    // 현재시간을 초기화한다.
        //    currentTime = 0;

        //    // 애니메이션
        //    anim.SetBool("AttackWait", true);
        //    anim.SetBool("Attack", true);

        //    // 상태를 Attack 으로 바꾼다.
        //    state = MolblinnState.Attack;
        //}
    }

    public void UpdateDamaged()
    {
        if (isDisturb)
        {
            // 체력을 감소시킨다.
            currentHP--;

            anim.SetTrigger("Damaged");
        }
    }

    private void UpdateDie()
    {
        GetComponent<Rigidbody>().mass = 500;
        // 1초 후에 파괴한다.
        Destroy(gameObject, 2);
        // 파괴할 때 검은 먼지 파티클시스템을 실행한다.

    }
    #endregion
}